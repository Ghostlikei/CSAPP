# Chapter 7 Machine level programming III Procedures

## 进程当中的机制

- 传递控制权
- 传递数据
- 内存管理
- 如何用机器指令来实现
- 如何尽可能地减少开销



## 内存栈

- 内存栈的示例

--> increasing address

[ bottom ｜ data ｜top     <- stack pointer(%rsp)

- 内存栈的一些规则

1.`%rsp`寄存器指向的是内存栈的最底端（最低地址）

2.内存栈是从**高地址**往**低地址**走的，当你添加一个数据的时候，内存栈的地址会减小

3.内存栈的管理和数据结构*栈*的管理是类似的，当pop一个元素的时候，仅仅移动**栈顶指针**而已，不会动原先位置的元素



### 汇编语言的实现

#### 传递指令

- `call`, `ret`

call会掉用%rip，让内存栈开放空间，存放函数的汇编代码

ret的作用是**逆转**call的效果，让内存栈进行pop操作，也就是**回到之前call的位置**

#### 传递数据

规定`%rdi %rsi %rdx %rcx %r8 %r9`来传递前六个参数，`%rax`来传递返回值

如果超过寄存器的范围，则掉用内存栈来传值

#### 管理本地数据

- 栈帧

使用`%rbp`来记录栈帧：%rbp -> |frame| <-%rsp

在函数当中掉用函数的时候，会把新掉用的函数放到栈帧里面，返回的时候栈帧会释放（解释了为什么递归调用不好）

- 内存当中存储数据

编译器一般会多开一些空间内，而且存在ret address之后，这是为了防止内存的内容被修改

- 不要随意用寄存器来**存储数据**

例如寄存器%rdx，如果foo()当中还掉用了bar()，bar可能会更改rdx当中的值

如果要解决这个问题通常有两种方法（约定）

1.调用者存储

调用者在**掉用之前**把临时变量存储在**栈帧**当中

2.被调用者存储

被调用者在**使用临时变量**之前存储在**栈帧**当中

被调用者在**返回之前** ***恢复***临时变量

### 寄存器使用约定

`%rax`:用于记录返回值，符合调用者存储，可以被程序修改

`%rdi...%r9`:用于存储变量，符合调用者存储

`%r10, %r11`:符合调用者存储，是调用者存储**临时变量**的区域

`%rbx, %r12-14`:符合被调用者存储，也就是说寄存器必须把值**push到栈中**，返回之前**pop**出来

`%rsp`：用push和pop机制实现callee save



