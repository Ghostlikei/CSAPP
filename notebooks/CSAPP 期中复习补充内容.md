# CSAPP 期中复习补充内容

## Chapter 2

1.**字长**，指的是指针的大小，

- 如果字长是w，那么机器的虚拟内存的范围就是$0$~$2^{w}-1$

- 32位机器和64位机器的说的是机器的字长大小

- 编译的时候可以用`-m32 -m64`选项来选择编译类型

- 32和64位机器基本数据类型唯一的**不同**在于**指针长度**分别为4和8个byte，同样，long和unsigned long也是4和8个byte

2.**大端存储**和**小端存储**

- 以0x01234567为例，

在大端的机器上存储的形式是01 23 45 67,地址从小到大

在小端的机器上存储的形式是**67 45 23 01**,地址从小到大

3.ascii,utf-8,unicode,gbk分别的编码形式是什么https://www.zhihu.com/question/23374078

4.inplace_swap函数（那个看起来很帅的异或操作，但是没什么用）当两个指针指向同一个数据的时候会置零

5.**掩码**是位运算当中的常用工具，可以起到地位，高位的屏蔽，置零等等操作（data lab当中会用很多次）

6.c语言当中+，-运算符的优先级比移位要高

7.补码的加法形成一个**阿贝尔群**，也就是说无论是不是溢出，(x+y)-y=x, (y+x)-x=y，但是浮点数加法并不构成

8.浮点数和舍入问题

9.int向double扩展的时候不会损失精度，但是int向float扩展的时候会损失

10.浮点数做取-仅仅是符号位取反

11.浮点数的乘法是不会负溢出的，最多到$+\infty$

## Chapter 3

1.汇编当中**字（word）**的概念是位扩展的时候遗留下来的，intel体系当中word为16个bits，l是32，q是64，b是8

2.movabsq指令只能以**寄存器**为目的地，源操作数可以是任意64位数值

3.movz_ _指令可以做符号位扩展，z表示zero（0），也就是零扩展，movzwl就是以单字做零扩展到双字

同样的，movs_ _就是做符号位扩展

cltq就是对%eax做符号位扩展到%rax,相当于movslq %eax,%rax

4.寄存器当中后16位分别为%ax, %bx,... (64,32位的后两个)，后8位分别是%al, %bl, ..., %sil, 都是以l结尾

%r8以后的寄存器后32位是%r8d， %r8w， %r8b

5.pushq %rax相当于把%rax的数据放到栈顶，popq %rax相当于把栈顶的数据**弹出到**%rax当中，

6.lea指令就是**不把内存当中的数据读出来**，然后进行寻址操作的加法和乘法，leaq 6(%rax), %rdx就是ret = x+6

7.salq为左移63为，w为15位，以此类推

8.cmp S2, S1的过程类似于S2-S1，然后设置四个flag，

9.cmovge就是根据比较的结果是不是ge来决定是否mov，cmovns 表示如果非负那就移动，s表示sign
